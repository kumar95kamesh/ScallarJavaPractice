Single Instance Guarantee:
Java ensures that each enum constant is instantiated only once. By declaring a singleton as an
enum with a single element (commonly named INSTANCE ), you inherently guarantee that only
one instance exists.

Serialization Safety:
Unlike conventional singletons (which might require special handling for serialization), enum
singletons are serialization-safe by default. When an enum is serialized, the JVM ensures that the
same instance is returned during deserialization.

Reflection-Proof:
Enum types in Java are inherently resistant to reflection-based attacks. The Java runtime
prevents instantiation of enum types via reflection, which means an enum singleton cannot be
broken by reflection hacks.

Simplicity and Conciseness:
Using an enum for a singleton is straightforward and requires minimal code. There's no need to
write extra code to handle multithreading, serialization, or reflection issues.

Extra part-- enums are eager initialized.
enums can not be extended.
and objects yaad bhi to nhi rkh skte.. kaise call kroge wrna.. 

These all are just instances 
MERCURY (3.303e+23, 2.4397e6),
		VENUS(4.869e+24, 6.0518e6),
		EARTH(5.976e+24, 6.37814e6),
		MARS(6.421e+23, 3.3972e6),
		JUPITER (1.9e+27,7.1492e7),
		SATURN (5.688e+26, 6.0268e7),
		URANUS (8.686e+25, 2.5559e7),
		NEPTUNE (1.024e+26, 2.4746e7);


		public enum Planet {
		MERCURY (3.303e+23, 2.4397e6),
		VENUS(4.869e+24, 6.0518e6),
		EARTH(5.976e+24, 6.37814e6),
		MARS(6.421e+23, 3.3972e6),
		JUPITER (1.9e+27,7.1492e7),
		SATURN (5.688e+26, 6.0268e7),
		URANUS (8.686e+25, 2.5559e7),
		NEPTUNE (1.024e+26, 2.4746e7);
		
		private final double mass; // in kilograms
		private final double radius; // in meters
		Planet(double mass, double radius) {
		this.mass = mass;
		this.radius = radius;
		
		private double mass() { return mass; }
		private double radius() { return radius; }
		
		// universal gravitational constant (m3 kg-1 s-2)
		public static final double G = 6.67300E-11;
		
		double surfaceGravity() {
		return G * mass / (radius * radius);
		
		double surfaceWeight(double otherMass) {
		return otherMass * surfaceGravity();
		}